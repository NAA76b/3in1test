# -*- coding: utf-8 -*-
"""modernized_ui.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bwigfzgEXWWQ52mDkFyXGLD54S5hGnwb
"""

# -*- coding: utf-8 -*-
"""
Master Workflow Tool (All-in-One) - Modernized UI

This script is a visually updated version of the original 3in1oldui.py.
The user interface has been modernized to match a clean, light, and spacious aesthetic,
while the backend application logic, data processing, and functions remain
identical to the original script, with specific formatting updates applied as requested.
"""

import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import pandas as pd
import os
import re
import threading
from datetime import datetime
import traceback

# The script requires libraries to be installed:
# pip install pywin32 python-docx openpyxl
try:
    import win32com.client as win32
    from docx import Document
    from docx.shared import Pt, RGBColor, Inches
    from docx.oxml.ns import qn
    from docx.oxml import OxmlElement
    from docx.enum.text import WD_ALIGN_PARAGRAPH
except ImportError:
    messagebox.showerror("Missing Libraries", "This application requires 'pywin32', 'python-docx', and 'openpyxl'.\nPlease install them by running:\npip install pywin32 python-docx openpyxl")
    exit()

#==========================================================================
# SHARED UTILITY FUNCTIONS (FROM ORIGINAL SCRIPT)
#==========================================================================
def get_default_output_path():
    """Gets the default output path, preferring a OneDrive Desktop if it exists."""
    onedrive_desktop = os.path.join(os.path.expanduser("~"), "OneDrive - FDA", "Desktop")
    if os.path.exists(onedrive_desktop):
        return onedrive_desktop
    return os.path.expanduser("~/Desktop")

def log_message_util(root, log_widget, msg, level='info'):
    """Utility to safely log messages to a Tkinter Text widget from any thread."""
    def _insert():
        if not log_widget.winfo_exists(): return
        log_widget.config(state='normal')
        # Simple color tagging for different levels
        tag_colors = {
            'success': '#228B22', # ForestGreen
            'error': '#B22222',   # Firebrick
            'info': '#464646'     # Dark Gray
        }
        log_widget.tag_config('success', foreground=tag_colors['success'])
        log_widget.tag_config('error', foreground=tag_colors['error'])
        log_widget.tag_config('info', foreground=tag_colors['info'])

        timestamp = datetime.now().strftime('%H:%M:%S')
        log_widget.insert(tk.END, f"[{timestamp}] {msg}\n", level)
        log_widget.config(state='disabled')
        log_widget.see(tk.END)
    if root and root.winfo_exists():
        root.after(0, _insert)

#==========================================================================
# TAB 1: PAY PERIOD REPORTER
#==========================================================================
class ReporterFrame(ttk.Frame):
    def __init__(self, container, app_instance, **kwargs):
        super().__init__(container, **kwargs)
        self.app = app_instance

        # --- Reporter Variables (from original script) ---
        self.history_file = tk.StringVar()
        self.employee_file = tk.StringVar()
        self.reporter_output_location = tk.StringVar(value=self.app.default_output_path)
        self.fill_logic = tk.StringVar(value="Smart Header + Dynamic Fill")
        self.manual_filename = tk.StringVar() # New for custom filenames

        self.grid_rowconfigure(1, weight=1)
        self.grid_columnconfigure(0, weight=1)

        # --- UI Modernization ---
        ttk.Label(self, text="Pay Period Report Generator", style='Header.TLabel').grid(row=0, column=0, columnspan=2, sticky='w', pady=(0, 20))

        content_frame = ttk.Frame(self)
        content_frame.grid(row=1, column=0, sticky='nsew')
        content_frame.grid_columnconfigure(1, weight=1) # Allow entry widgets to expand

        # Row 1: History File
        ttk.Label(content_frame, text="1. Select History File").grid(row=0, column=0, columnspan=2, sticky='w', pady=(0, 5))
        history_entry_frame = ttk.Frame(content_frame)
        history_entry_frame.grid(row=1, column=1, sticky='ew', pady=(0, 15))
        history_entry_frame.columnconfigure(0, weight=1)
        history_entry = ttk.Entry(history_entry_frame, textvariable=self.history_file, state='readonly')
        history_entry.grid(row=0, column=0, sticky='ew', ipady=5)
        ttk.Button(history_entry_frame, text="Browse...", command=lambda: self.browse_file(self.history_file, "Select History File"), style='Neutral.TButton').grid(row=0, column=1, padx=(10,0))

        # Row 2: Employee File
        ttk.Label(content_frame, text="2. Select Employee File").grid(row=2, column=0, columnspan=2, sticky='w', pady=(0, 5))
        employee_entry_frame = ttk.Frame(content_frame)
        employee_entry_frame.grid(row=3, column=1, sticky='ew', pady=(0, 15))
        employee_entry_frame.columnconfigure(0, weight=1)
        employee_entry = ttk.Entry(employee_entry_frame, textvariable=self.employee_file, state='readonly')
        employee_entry.grid(row=0, column=0, sticky='ew', ipady=5)
        ttk.Button(employee_entry_frame, text="Browse...", command=lambda: self.browse_file(self.employee_file, "Select Employee File"), style='Neutral.TButton').grid(row=0, column=1, padx=(10,0))

        # Row 3: Output Location
        ttk.Label(content_frame, text="3. Select Output Location").grid(row=4, column=0, columnspan=2, sticky='w', pady=(0, 5))
        output_entry_frame = ttk.Frame(content_frame)
        output_entry_frame.grid(row=5, column=1, sticky='ew', pady=(0, 15))
        output_entry_frame.columnconfigure(0, weight=1)
        reporter_output_entry = ttk.Entry(output_entry_frame, textvariable=self.reporter_output_location, state='readonly')
        reporter_output_entry.grid(row=0, column=0, sticky='ew', ipady=5)
        ttk.Button(output_entry_frame, text="Browse...", command=lambda: self.browse_directory(self.reporter_output_location), style='Neutral.TButton').grid(row=0, column=1, padx=(10,0))

        # Row 4: Fill Logic
        ttk.Label(content_frame, text="4. Select Fill Down Logic").grid(row=6, column=0, columnspan=2, sticky='w', pady=(0, 5))
        fill_logic_combo = ttk.Combobox(content_frame, textvariable=self.fill_logic, values=["No Fill Down", "Dynamic Keyword Fill", "Smart Header + Dynamic Fill"], state='readonly')
        fill_logic_combo.grid(row=7, column=1, sticky='ew', pady=(0, 15), ipady=4)

        # Row 5: Custom Filename (New)
        ttk.Label(content_frame, text="5. Custom Filename (Optional)").grid(row=8, column=0, columnspan=2, sticky='w', pady=(0, 5))
        filename_entry = ttk.Entry(content_frame, textvariable=self.manual_filename)
        filename_entry.grid(row=9, column=1, sticky='ew', pady=(0,15), ipady=5)

        # --- Action Frame ---
        action_frame = ttk.Frame(self)
        action_frame.grid(row=2, column=0, sticky='ew', pady=(20, 0))
        action_frame.grid_columnconfigure(0, weight=1)

        self.process_button = ttk.Button(action_frame, text="Generate Comparison Reports", command=self.run_process, style='MutedGreen.TButton')
        self.process_button.grid(row=0, column=0, ipady=10, sticky='ew')

        self.progress = ttk.Progressbar(action_frame, orient='horizontal', mode='indeterminate', style='MutedGreen.Horizontal.TProgressbar')
        self.progress.grid(row=1, column=0, pady=(15, 10), sticky='ew')

        log_frame = ttk.LabelFrame(action_frame, text="Reporter Log", padding="10")
        log_frame.grid(row=2, column=0, sticky='nsew', pady=(10, 0))
        action_frame.grid_rowconfigure(2, weight=1)
        self.log_text = tk.Text(log_frame, height=8, state='disabled', bg=self.app.WIDGET_BG, fg=self.app.FG_COLOR, wrap='word', borderwidth=0, highlightthickness=0)
        self.log_text.pack(expand=True, fill='both')

        # --- Auto-load files on startup ---
        thread = threading.Thread(target=self.find_latest_files, daemon=True)
        thread.start()

    def find_latest_files(self):
        """Scans Desktop and Downloads for the newest report files."""
        try:
            log_message_util(self.app.root, self.log_text, "Reporter: Searching for latest History and Employee files...")
            search_paths = [
                os.path.join(os.path.expanduser("~"), "Desktop"),
                os.path.join(os.path.expanduser("~"), "Downloads")
            ]

            latest_hist, latest_hist_time = None, 0
            latest_emp, latest_emp_time = None, 0

            for path in search_paths:
                if not os.path.isdir(path):
                    continue
                for filename in os.listdir(path):
                    if not filename.lower().endswith(('.xlsx', '.xlsm')):
                        continue

                    full_path = os.path.join(path, filename)
                    mod_time = os.path.getmtime(full_path)

                    # Check for history file keywords
                    if "hist" in filename.lower() and "report" in filename.lower():
                        if mod_time > latest_hist_time:
                            latest_hist_time = mod_time
                            latest_hist = full_path

                    # Check for employee file keywords
                    if "emp id" in filename.lower() and "report" in filename.lower():
                        if mod_time > latest_emp_time:
                            latest_emp_time = mod_time
                            latest_emp = full_path

            if latest_hist:
                self.app.root.after(0, lambda: self.history_file.set(latest_hist))
                log_message_util(self.app.root, self.log_text, f"Reporter: Pre-loaded history file: {os.path.basename(latest_hist)}", 'success')
            else:
                log_message_util(self.app.root, self.log_text, "Reporter: No recent history file found.", 'info')

            if latest_emp:
                self.app.root.after(0, lambda: self.employee_file.set(latest_emp))
                log_message_util(self.app.root, self.log_text, f"Reporter: Pre-loaded employee file: {os.path.basename(latest_emp)}", 'success')
            else:
                log_message_util(self.app.root, self.log_text, "Reporter: No recent employee file found.", 'info')

        except Exception as e:
            log_message_util(self.app.root, self.log_text, f"Reporter: Error during file pre-load: {e}", 'error')

    def browse_file(self, string_var, title):
        filename = filedialog.askopenfilename(title=title, filetypes=[("Excel files", "*.xlsx *.xlsm"), ("All files", "*.*")])
        if filename:
            string_var.set(filename)
            log_message_util(self.app.root, self.log_text, f"File selected: {os.path.basename(filename)}")

    def browse_directory(self, string_var):
        directory = filedialog.askdirectory(title="Select Output Location", initialdir=string_var.get())
        if directory:
            string_var.set(directory)
            log_message_util(self.app.root, self.log_text, f"Output location set to: {directory}")

    def run_process(self):
        if not self.history_file.get() or not self.employee_file.get():
            messagebox.showerror("Input Error", "Please select both History and Employee files.")
            return

        self.process_button.config(state='disabled')
        self.progress.start(10)
        log_message_util(self.app.root, self.log_text, "Reporter: Processing... Please wait.")

        thread = threading.Thread(target=self.process_files_thread)
        thread.start()

    def process_files_thread(self):
        try:
            history_df = self.clean_report_data(self.history_file.get())
            employee_df = self.clean_report_data(self.employee_file.get())

            matched_df, unmatched_hist, unmatched_emp = self.validate_employee_ids(history_df, employee_df)
            log_message_util(self.app.root, self.log_text, f"Reporter: Found {len(matched_df)} matched employees.")

            improved, declined, unchanged = self.track_compliance_changes(matched_df)
            log_message_util(self.app.root, self.log_text, f"Reporter: {len(improved)} employees improved compliance.")

            output_dir = self.reporter_output_location.get()
            manual_name = self.manual_filename.get().strip()

            if manual_name:
                base_name = manual_name
                matched_filename = os.path.join(output_dir, f"{base_name}_Matched.xlsx")
                unmatched_hist_filename = os.path.join(output_dir, f"{base_name}_Unmatched_History.xlsx")
                unmatched_emp_filename = os.path.join(output_dir, f"{base_name}_Unmatched_Employee.xlsx")
            else:
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                matched_filename = os.path.join(output_dir, f"Matched_Report_{timestamp}.xlsx")
                unmatched_hist_filename = os.path.join(output_dir, f"Unmatched_History_{timestamp}.xlsx")
                unmatched_emp_filename = os.path.join(output_dir, f"Unmatched_Employee_{timestamp}.xlsx")

            unmatched_hist.to_excel(unmatched_hist_filename, index=False)
            unmatched_emp.to_excel(unmatched_emp_filename, index=False)

            with pd.ExcelWriter(matched_filename) as writer:
                matched_df.to_excel(writer, sheet_name='Matched_Employees', index=False)
                improved.to_excel(writer, sheet_name='Improved_Compliance', index=False)
                declined.to_excel(writer, sheet_name='Declined_Compliance', index=False)

            self.app.root.after(0, self.process_complete, output_dir)
        except Exception as e:
            self.app.root.after(0, self.process_error, e)

    def clean_report_data(self, filepath):
        header_row = self.find_header_row(filepath)
        if header_row is None:
            raise ValueError(f"Could not determine header row in {os.path.basename(filepath)}")
        df = pd.read_excel(filepath, skiprows=header_row)
        df.rename(columns=lambda c: c.strip(), inplace=True)

        rename_dict = {}
        unmapped_cols = list(df.columns)
        def find_and_map(standard_name, rules):
            for col in unmapped_cols:
                col_lower = str(col).lower().replace(':', '')
                if all(rule(col_lower) for rule in rules):
                    rename_dict[col] = standard_name
                    unmapped_cols.remove(col)
                    return

        find_and_map('Time Sheet Owner Name', [lambda c: 'timesheet' in c or 'time sheet' in c, lambda c: 'owner' in c, lambda c: 'name' in c])
        find_and_map('Compliance %', [lambda c: 'compliance' in c, lambda c: '%' in c])
        find_and_map('Super Office', [lambda c: 'superoffice' in c or 'super office' in c])
        find_and_map('Division', [lambda c: 'division' in c])

        df.rename(columns=rename_dict, inplace=True)

        logic = self.fill_logic.get()
        if logic != "No Fill Down":
            cols_to_fill = [col for col in df.columns if any(keyword in str(col).lower() for keyword in ['super', 'division'])]
            if cols_to_fill:
                df[cols_to_fill] = df[cols_to_fill].fillna(method='ffill')

        if 'Time Sheet Owner Name' in df.columns:
            df.dropna(subset=['Time Sheet Owner Name'], inplace=True)
        else:
            raise ValueError("Critical Error: 'Time Sheet Owner Name' column could not be identified.")
        return df

    def find_header_row(self, filepath):
        log_message_util(self.app.root, self.log_text, f"Reporter: Flexibly searching for header in {os.path.basename(filepath)}...")
        try:
            df_preview = pd.read_excel(filepath, header=None, nrows=50)
            required_keywords = ['time sheet', 'compliance %', 'super office']

            for i, row in df_preview.iterrows():
                row_str = ' '.join(str(x) for x in row.dropna().values).lower().replace(':', '')
                if all(keyword in row_str for keyword in required_keywords):
                    log_message_util(self.app.root, self.log_text, f"Reporter: Header found on row {i + 1}", 'success')
                    return i

            log_message_util(self.app.root, self.log_text, f"Reporter: Error: Could not find a valid header row.", 'error')
            return None

        except Exception as e:
            log_message_util(self.app.root, self.log_text, f"Reporter: Error reading {os.path.basename(filepath)}: {e}", 'error')
            return None

    def validate_employee_ids(self, df1, df2):
        df1['Name_Standard'] = df1['Time Sheet Owner Name'].str.upper().str.strip()
        df2['Name_Standard'] = df2['Time Sheet Owner Name'].str.upper().str.strip()
        matched = pd.merge(df1, df2, on='Name_Standard', how='inner', suffixes=('_hist', '_emp'))
        only_in_file1 = df1[~df1['Name_Standard'].isin(df2['Name_Standard'])]
        only_in_file2 = df2[~df2['Name_Standard'].isin(df1['Name_Standard'])]
        return matched, only_in_file1, only_in_file2

    def track_compliance_changes(self, matched_df):
        matched_df['Compliance %_emp'] = pd.to_numeric(matched_df['Compliance %_emp'], errors='coerce')
        matched_df['Compliance %_hist'] = pd.to_numeric(matched_df['Compliance %_hist'], errors='coerce')
        matched_df['Compliance_Change'] = matched_df['Compliance %_emp'] - matched_df['Compliance %_hist']
        return (matched_df[matched_df['Compliance_Change'] > 0],
                matched_df[matched_df['Compliance_Change'] < 0],
                matched_df[matched_df['Compliance_Change'] == 0])

    def process_complete(self, output_dir):
        self.progress.stop()
        self.process_button.config(state='normal')
        log_message_util(self.app.root, self.log_text, "Reporter: Analysis complete. Reports generated successfully!", 'success')
        messagebox.showinfo("Success", f"Reports generated and saved to:\n{output_dir}")

    def process_error(self, error):
        self.progress.stop()
        self.process_button.config(state='normal')
        log_message_util(self.app.root, self.log_text, f"Reporter: Error: {error}", 'error')
        messagebox.showerror("Processing Error", f"An error occurred in Reporter:\n{error}")

#==========================================================================
# TAB 2: HELPER SHEET FORMATTER
#==========================================================================
class FormatterFrame(ttk.Frame):
    def __init__(self, container, app_instance, **kwargs):
        super().__init__(container, **kwargs)
        self.app = app_instance

        # --- Formatter Variables ---
        self.source_file = tk.StringVar()
        self.pay_period = tk.StringVar()
        self.report_day = tk.StringVar(value="Wednesday")
        self.output_location = tk.StringVar(value=self.app.default_output_path)
        self.manual_filename = tk.StringVar() # New for custom filenames

        self.pp_data = self.get_pay_period_data()
        self.pp_display_list = [item['display'] for item in self.pp_data]

        # --- UI Modernization ---
        self.grid_rowconfigure(1, weight=1)
        self.grid_columnconfigure(0, weight=1)

        ttk.Label(self, text="Helper Sheet Data Formatter", style='Header.TLabel').grid(row=0, column=0, sticky='w', pady=(0, 20))

        content_frame = ttk.Frame(self)
        content_frame.grid(row=1, column=0, sticky='nsew')
        content_frame.grid_columnconfigure(1, weight=1)

        # Row 1: Source File
        ttk.Label(content_frame, text="1. Select Source Excel File").grid(row=0, column=0, columnspan=2, sticky='w', pady=(0, 5))
        file_entry_frame = ttk.Frame(content_frame)
        file_entry_frame.grid(row=1, column=1, sticky='ew', pady=(0, 15))
        file_entry_frame.columnconfigure(0, weight=1)
        file_entry = ttk.Entry(file_entry_frame, textvariable=self.source_file, state='readonly')
        file_entry.grid(row=0, column=0, sticky='ew', ipady=5)
        ttk.Button(file_entry_frame, text="Browse...", command=lambda: self.browse_file(self.source_file, "Select Source Excel File"), style='Neutral.TButton').grid(row=0, column=1, padx=10)

        # Row 2: Pay Period
        ttk.Label(content_frame, text="2. Select Pay Period").grid(row=2, column=0, columnspan=2, sticky='w', pady=(0, 5))
        pp_combo = ttk.Combobox(content_frame, textvariable=self.pay_period, values=self.pp_display_list, state='readonly')
        pp_combo.grid(row=3, column=1, sticky='ew', pady=(0, 15), ipady=4)
        if self.pp_display_list: pp_combo.set(self.pp_display_list[0])

        # Row 3: Report Day
        ttk.Label(content_frame, text="3. Select Report Day").grid(row=4, column=0, columnspan=2, sticky='w', pady=(0, 5))
        day_combo = ttk.Combobox(content_frame, textvariable=self.report_day, values=["Monday", "Wednesday"], state='readonly')
        day_combo.grid(row=5, column=1, sticky='ew', pady=(0, 15), ipady=4)

        # Row 4: Output Location
        ttk.Label(content_frame, text="4. Select Output Location").grid(row=6, column=0, columnspan=2, sticky='w', pady=(0, 5))
        output_entry_frame = ttk.Frame(content_frame)
        output_entry_frame.grid(row=7, column=1, sticky='ew', pady=(0, 15))
        output_entry_frame.columnconfigure(0, weight=1)
        output_entry = ttk.Entry(output_entry_frame, textvariable=self.output_location, state='readonly')
        output_entry.grid(row=0, column=0, sticky='ew', ipady=5)
        ttk.Button(output_entry_frame, text="Browse...", command=lambda: self.browse_directory(self.output_location), style='Neutral.TButton').grid(row=0, column=1, padx=10)

        # Row 5: Custom Filename (New)
        ttk.Label(content_frame, text="5. Custom Filename (Optional)").grid(row=8, column=0, columnspan=2, sticky='w', pady=(0, 5))
        filename_entry = ttk.Entry(content_frame, textvariable=self.manual_filename)
        filename_entry.grid(row=9, column=1, sticky='ew', pady=(0,15), ipady=5)

        # --- Action Frame ---
        action_frame = ttk.Frame(self)
        action_frame.grid(row=2, column=0, sticky='ew', pady=(20, 0))
        action_frame.grid_columnconfigure(0, weight=1)

        self.process_button = ttk.Button(action_frame, text="Generate Formatted Data", command=self.run_process, style='MutedBlue.TButton')
        self.process_button.grid(row=0, column=0, sticky='ew', ipady=10)

        self.progress = ttk.Progressbar(action_frame, orient='horizontal', mode='indeterminate', style='MutedBlue.Horizontal.TProgressbar')
        self.progress.grid(row=1, column=0, sticky='ew', pady=(15, 10))

        log_frame = ttk.LabelFrame(action_frame, text="Formatter Log", padding="10")
        log_frame.grid(row=2, column=0, sticky='nsew', pady=(10, 0))
        action_frame.grid_rowconfigure(2, weight=1)
        log_text_container = ttk.Frame(log_frame)
        log_text_container.pack(expand=True, fill='both')
        log_text_container.grid_rowconfigure(0, weight=1)
        log_text_container.grid_columnconfigure(0, weight=1)

        self.log_text = tk.Text(log_text_container, height=8, state='disabled', bg=self.app.WIDGET_BG, fg=self.app.FG_COLOR, wrap='word', borderwidth=0, highlightthickness=0)
        self.log_text.grid(row=0, column=0, sticky='nsew')

        log_scrollbar = ttk.Scrollbar(log_text_container, orient='vertical', command=self.log_text.yview)
        log_scrollbar.grid(row=0, column=1, sticky='ns')
        self.log_text.config(yscrollcommand=log_scrollbar.set)

    def browse_file(self, string_var, title):
        filename = filedialog.askopenfilename(title=title, filetypes=[("Excel files", "*.xlsx *.xlsm"), ("All files", "*.*")])
        if filename:
            string_var.set(filename)
            log_message_util(self.app.root, self.log_text, f"File selected: {os.path.basename(filename)}")

    def browse_directory(self, string_var):
        directory = filedialog.askdirectory(title="Select Output Location", initialdir=string_var.get())
        if directory:
            string_var.set(directory)
            log_message_util(self.app.root, self.log_text, f"Output location set to: {directory}")

    def get_pay_period_data(self):
        raw_data = """2,12/29/2024,1/11/2025
3,1/12/2025,1/25/2025
4,1/26/2025,2/8/2025
5,2/9/2025,2/22/2025
6,2/23/2025,3/8/2025
7,3/9/2025,3/22/2025
8,3/23/2025,4/5/2025
9,4/6/2025,4/19/2025
10,4/20/2025,5/3/2025
11,5/4/2025,5/17/2025
12,5/18/2025,5/31/2025
13,6/1/2025,6/14/2025
14,6/15/2025,6/28/2025
15,6/29/2025,7/12/2025
16,7/13/2025,7/26/2025
17,7/27/2025,8/9/2025
18,8/10/2025,8/23/2025
19,8/24/2025,9/6/2025
20,9/7/2025,9/20/2025
21,9/21/2025,10/4/2025
22,10/5/2025,10/18/2025
23,10/19/2025,11/1/2025
24,11/2/2025,11/15/2025
25,11/16/2025,11/29/2025
1,11/30/2025,12/13/2025
2,12/14/2025,12/27/2025
3,12/28/2025,1/10/2026
4,1/11/2026,1/24/2026
5,1/25/2026,2/7/2026"""
        pay_periods = []
        for line in raw_data.strip().split('\n'):
            pp, start, end = line.strip().split(',')
            year = pd.to_datetime(start).year
            pay_periods.append({"display": f"PP {pp} ({start} - {end})", "pp": int(pp), "year": year})
        return pay_periods

    def run_process(self):
        if not self.source_file.get() or not self.pay_period.get():
            messagebox.showerror("Input Error", "Please select a source file and a pay period.")
            return

        self.process_button.config(state='disabled')
        self.progress.start(10)
        log_message_util(self.app.root, self.log_text, "Formatter: Processing... Please wait.")

        thread = threading.Thread(target=self.process_files_thread)
        thread.start()

    def process_files_thread(self):
        try:
            source_path = self.source_file.get()
            pp_display = self.pay_period.get()
            selected_day = self.report_day.get().upper()

            pp_info = next((item for item in self.pp_data if item['display'] == pp_display), None)
            if not pp_info:
                raise ValueError("Could not find data for the selected pay period.")
            pp_num, pp_year = pp_info['pp'], pp_info['year']
            log_message_util(self.app.root, self.log_text, f"Formatter: Processing for PP {pp_num}, Year {pp_year}")

            final_dfs = []
            try:
                df_excused = pd.read_excel(source_path, sheet_name='Excused List', skiprows=4)
                df_excused.dropna(subset=['EMPLOYEE_ID'], inplace=True)
                df_excused = df_excused[pd.to_numeric(df_excused['EMPLOYEE_ID'], errors='coerce').notna()].copy()
                names = df_excused['Employee Name'].str.split(n=1, expand=True)
                df_excused['User First Name'] = names[0]
                df_excused['User Last Name'] = names[1].apply(lambda x: x.split()[-1] if isinstance(x, str) else None)
                df_excused['Full Name (First, Last)'] = df_excused['Employee Name']
                df_excused.rename(columns={'EMPLOYEE_ID': 'Employee ID'}, inplace=True)
                df_excused['YEAR'], df_excused['PP'] = pp_year, pp_num
                df_excused['Column1'] = f"PP {pp_num} - EXCUSED LIST TABLEAU - {selected_day}"
                final_dfs.append(df_excused)
                log_message_util(self.app.root, self.log_text, f"Formatter: Found {len(df_excused)} from Excused List.", 'success')
            except Exception as e:
                log_message_util(self.app.root, self.log_text, f"Formatter: Could not process 'Excused List'. Error: {e}", 'error')

            try:
                df_inactive = pd.read_excel(source_path, sheet_name='Inactive List', skiprows=1)
                df_inactive.dropna(subset=['HHS ID'], inplace=True)
                df_inactive = df_inactive[pd.to_numeric(df_inactive['HHS ID'], errors='coerce').notna()].copy()
                df_inactive.rename(columns={'HHS ID': 'Employee ID', 'First Name': 'User First Name', 'Last Name': 'User Last Name'}, inplace=True)
                df_inactive['Full Name (First, Last)'] = df_inactive['User First Name'] + ' ' + df_inactive['User Last Name']
                df_inactive['YEAR'], df_inactive['PP'] = pp_year, pp_num
                df_inactive['Column1'] = f"PP{pp_num}, Inactive in EASE"
                final_dfs.append(df_inactive)
                log_message_util(self.app.root, self.log_text, f"Formatter: Found {len(df_inactive)} from Inactive List.", 'success')
            except Exception as e:
                log_message_util(self.app.root, self.log_text, f"Formatter: Could not process 'Inactive List'. Error: {e}", 'error')

            if not final_dfs:
                raise ValueError("No data could be processed.")

            final_df = pd.concat(final_dfs, ignore_index=True)
            output_columns = ['YEAR', 'PP', 'User Last Name', 'User First Name', 'Full Name (First, Last)', 'Employee ID', 'Column1']
            final_df = final_df[output_columns]
            final_df['Employee ID'] = pd.to_numeric(final_df['Employee ID']).astype('Int64')

            output_dir = self.output_location.get()
            manual_name = self.manual_filename.get().strip()

            if manual_name:
                output_filename = os.path.join(output_dir, f"{manual_name}.csv")
            else:
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                output_filename = os.path.join(output_dir, f"Formatted_Helper_Data_{timestamp}.csv")

            final_df.to_csv(output_filename, index=False)

            self.app.root.after(0, self.process_complete, output_filename)
        except Exception as e:
            self.app.root.after(0, self.process_error, e)

    def process_complete(self, output_path):
        self.progress.stop()
        self.process_button.config(state='normal')
        log_message_util(self.app.root, self.log_text, f"Formatter: Success! Formatted data saved to {os.path.basename(output_path)}", 'success')
        messagebox.showinfo("Success", f"Processing complete.\n\nFile saved to:\n{output_path}")

    def process_error(self, error):
        self.progress.stop()
        self.process_button.config(state='normal')
        log_message_util(self.app.root, self.log_text, f"Formatter: Error: {error}", 'error')
        messagebox.showerror("Processing Error", f"An error occurred in Formatter:\n{error}")

#==========================================================================
# TAB 3: OFFICE EMAILER
#==========================================================================
class EmailerFrame(ttk.Frame):
    def __init__(self, container, app_instance, **kwargs):
        super().__init__(container, **kwargs)
        self.app = app_instance

        # --- Emailer Variables (from original script) ---
        self.source_file = tk.StringVar()
        self.current_pp = tk.StringVar()
        self.manual_filename = tk.StringVar()
        self.output_format = tk.StringVar(value="Outlook")
        self.word_output_location = tk.StringVar(value=self.app.default_output_path)
        self.office_vars = {}
        self.dataframe = None
        self.dates_df = None
        self.director_data = {}
        self.non_reporters_data = {}

        # --- UI Modernization ---
        self.grid_columnconfigure(0, weight=2, minsize=400) # Left controls panel
        self.grid_columnconfigure(1, weight=3) # Right log panel
        self.grid_rowconfigure(1, weight=1)

        ttk.Label(self, text="Office Participation Emailer", style='Header.TLabel').grid(row=0, column=0, columnspan=2, sticky='w', pady=(0, 20))

        # --- Left Controls Panel ---
        self.controls_frame = ttk.Frame(self)
        self.controls_frame.grid(row=1, column=0, sticky='nsew', padx=(0, 20))

        # 1. Data Digest File
        ttk.Label(self.controls_frame, text="1. Select Data Digest File", style='Bold.TLabel').pack(anchor='w', pady=(0,5))
        file_entry_frame = ttk.Frame(self.controls_frame)
        file_entry_frame.pack(fill='x', pady=(0,15))
        file_entry_frame.columnconfigure(0, weight=1)
        self.file_entry = ttk.Entry(file_entry_frame, textvariable=self.source_file, state='readonly')
        self.file_entry.grid(row=0, column=0, sticky='ew', ipady=5)
        ttk.Button(file_entry_frame, text="Browse...", command=self.load_data, style='Neutral.TButton').grid(row=0, column=1, padx=(10,0))

        # 2. Pay Period
        ttk.Label(self.controls_frame, text="2. Pay Period Being Reported", style='Bold.TLabel').pack(anchor='w', pady=(0,5))
        self.pp_entry = ttk.Entry(self.controls_frame, textvariable=self.current_pp)
        self.pp_entry.pack(fill='x', ipady=5, pady=(0, 15))

        # 3. Select Offices
        office_frame = ttk.LabelFrame(self.controls_frame, text="3. Select Offices", padding=10)
        office_frame.pack(fill='both', expand=True, pady=(0, 10))
        office_frame.rowconfigure(1, weight=1)
        office_frame.columnconfigure(0, weight=1)

        toggle_button_frame = ttk.Frame(office_frame)
        toggle_button_frame.grid(row=0, column=0, sticky='ew', pady=(0,10))
        toggle_button_frame.columnconfigure(0, weight=1)
        toggle_button_frame.columnconfigure(1, weight=1)
        ttk.Button(toggle_button_frame, text="Select All", command=lambda: self.toggle_all_offices(True), style='Neutral.TButton').grid(row=0, column=0, sticky='ew', padx=(0,5))
        ttk.Button(toggle_button_frame, text="Select None", command=lambda: self.toggle_all_offices(False), style='Neutral.TButton').grid(row=0, column=1, sticky='ew', padx=(5,0))

        # Scrollable Canvas for Office List
        canvas_frame = ttk.Frame(office_frame)
        canvas_frame.grid(row=1, column=0, sticky='nsew')
        canvas_frame.rowconfigure(0, weight=1)
        canvas_frame.columnconfigure(0, weight=1)
        self.office_canvas = tk.Canvas(canvas_frame, bg=self.app.WIDGET_BG, highlightthickness=0)
        self.office_list_frame = ttk.Frame(self.office_canvas)
        self.office_scrollbar = ttk.Scrollbar(canvas_frame, orient="vertical", command=self.office_canvas.yview)
        self.office_canvas.configure(yscrollcommand=self.office_scrollbar.set)
        self.office_scrollbar.grid(row=0, column=1, sticky='ns')
        self.office_canvas.grid(row=0, column=0, sticky='nsew')
        self.office_canvas.create_window((0,0), window=self.office_list_frame, anchor="nw")
        self.office_list_frame.bind("<Configure>", lambda e: self.office_canvas.configure(scrollregion=self.office_canvas.bbox("all")))

        # --- Bottom Controls (within the left panel) ---
        bottom_controls_frame = ttk.Frame(self.controls_frame)
        bottom_controls_frame.pack(fill='x', side='bottom', pady=(10,0))

        # 4. Output Format
        self.output_frame = ttk.LabelFrame(bottom_controls_frame, text="4. Select Output Format", padding=10)
        self.output_frame.pack(fill='x', pady=(0, 10))
        ttk.Radiobutton(self.output_frame, text="Open in Outlook", variable=self.output_format, value="Outlook", command=self.toggle_word_path_visibility).pack(anchor='w', padx=5, pady=2)
        ttk.Radiobutton(self.output_frame, text="Generate Word Doc", variable=self.output_format, value="Word", command=self.toggle_word_path_visibility).pack(anchor='w', padx=5, pady=2)

        # 5. Word Filename
        self.word_output_frame = ttk.LabelFrame(bottom_controls_frame, text="5. Custom Filename (Optional)", padding=10)
        self.word_output_entry = ttk.Entry(self.word_output_frame, textvariable=self.manual_filename)
        self.word_output_entry.pack(fill='x', expand=True, ipady=5, pady=(0, 5))
        ttk.Label(self.word_output_frame, text="e.g., YYYY.MM.DD_PP## Emails.docx", style='Info.TLabel').pack(anchor='w')

        # Generate Button
        self.generate_button = ttk.Button(bottom_controls_frame, text="Generate Emails", style='MutedPurple.TButton', command=self.run_generation, state='disabled')
        self.generate_button.pack(fill='x', ipady=10, pady=(10, 0))

        # --- Right Log Panel ---
        log_panel_frame = ttk.Frame(self)
        log_panel_frame.grid(row=1, column=1, sticky='nsew')
        log_panel_frame.rowconfigure(0, weight=1)
        log_panel_frame.columnconfigure(0, weight=1)

        log_frame = ttk.LabelFrame(log_panel_frame, text="Emailer Log", padding="10")
        log_frame.grid(row=0, column=0, sticky='nsew')
        log_frame.rowconfigure(0, weight=1)
        log_frame.columnconfigure(0, weight=1)

        self.log_text = tk.Text(log_frame, state='disabled', bg=self.app.WIDGET_BG, fg=self.app.FG_COLOR, wrap='word', borderwidth=0, highlightthickness=0)
        self.log_text.pack(expand=True, fill='both')

        self.toggle_word_path_visibility()

    def toggle_word_path_visibility(self, *args):
        if self.output_format.get() == "Word":
            self.word_output_frame.pack(fill='x', pady=(0, 10))
        else:
            self.word_output_frame.pack_forget()

    def toggle_all_offices(self, select):
        for var in self.office_vars.values():
            var.set(select)

    def load_data(self):
        filepath = filedialog.askopenfilename(
            title="Select Data Digest",
            filetypes=[("Excel files", "*.xlsx *.xlsm"), ("All files", "*.*")]
        )
        if not filepath: return

        self.source_file.set(filepath)
        log_message_util(self.app.root, self.log_text, f"VERBOSE: Starting data load from: {filepath}")
        try:
            xls = pd.ExcelFile(filepath)
            log_message_util(self.app.root, self.log_text, "VERBOSE: Excel file opened.")

            df = pd.read_excel(xls, sheet_name='Summary Report', skiprows=2, engine='openpyxl')
            log_message_util(self.app.root, self.log_text, "VERBOSE: 'Summary Report' sheet read.")
            df.columns = [str(col).strip() for col in df.columns]
            df.dropna(subset=['Office'], inplace=True)
            df = df[~df['Office'].str.contains('Grand Total', case=False, na=False)]
            self.dataframe = df[df['Office'].str.match(r'^[A-Z]{2,5}$')].copy()
            log_message_util(self.app.root, self.log_text, f"VERBOSE: 'Summary Report' processed. Found {len(self.dataframe)} valid office rows.")

            self.dates_df = pd.read_excel(xls, sheet_name='Dates', engine='openpyxl')
            log_message_util(self.app.root, self.log_text, "VERBOSE: 'Dates' sheet read successfully.")

            directors_raw_df = pd.read_excel(xls, sheet_name='Office Directors', header=None, engine='openpyxl')
            self.director_data = {}
            for col in directors_raw_df.columns:
                col_data = directors_raw_df[col]
                office_abbr = col_data[0]
                if office_abbr and isinstance(office_abbr, str):
                    self.director_data[office_abbr] = {
                        'Director Name': col_data[4], 'Director Email': col_data[5],
                        'Deputy Name': col_data[6], 'Deputy Email': col_data[7],
                        'CC 1': col_data[8], 'CC 2': col_data[9], 'CC 3': col_data[10],
                        'CC 4': col_data[11], 'CC 5': col_data[12], 'CC 6': col_data[13],
                        'CC 7': col_data[14], 'CC 8': col_data[15], 'CC 9': col_data[16],
                        'CC 10': col_data[17], 'CC 11': col_data[18],
                        'BCC 1': col_data[20], 'BCC 2': col_data[21]
                    }
            log_message_util(self.app.root, self.log_text, "VERBOSE: 'Office Directors' sheet processed into dictionary.")

            try:
                pivot_sheet_name = None
                for sheet in xls.sheet_names:
                    try:
                        header_check_df = pd.read_excel(xls, sheet_name=sheet, header=None, skiprows=35, nrows=1, usecols='H')
                        if "SuperOffice" in str(header_check_df.iloc[0,0]) or "Super Office" in str(header_check_df.iloc[0,0]):
                            pivot_sheet_name = sheet
                            break
                    except Exception:
                        continue

                if not pivot_sheet_name:
                    raise ValueError("Could not find a sheet with 'Super Office' in cell H36.")

                log_message_util(self.app.root, self.log_text, f"VERBOSE: Found pivot data on sheet named '{pivot_sheet_name}'.")

                pivot_df = pd.read_excel(xls, sheet_name=pivot_sheet_name, header=35)
                pivot_df.columns = [str(h).strip().replace('↑','').strip() for h in pivot_df.columns]

                pivot_df.rename(columns={
                    'SuperOffice': 'Super_Office', 'Super Office': 'Super_Office',
                    'TimeSheet: Owner Name': 'Owner_Name', 'Time Sheet: Owner Name': 'Owner_Name',
                    'SumofSum of Hours': 'Sum_of_Hours', 'Sum of Sum of Hours': 'Sum_of_Hours'
                }, inplace=True)

                pivot_df.dropna(subset=['Owner_Name'], inplace=True)

                self.non_reporters_data = {}
                for index, row in pivot_df.iterrows():
                    office_full_name = row['Super_Office']
                    office_abbr = next((abbr for abbr, name in self.app.office_name_map.items() if name == office_full_name), None)
                    if office_abbr:
                        if office_abbr not in self.non_reporters_data:
                            self.non_reporters_data[office_abbr] = []

                        hours = row['Sum_of_Hours']
                        name = row['Owner_Name']
                        status = " - Partial Reporter" if hours > 0 else " - Did Not Report"
                        self.non_reporters_data[office_abbr].append(f"{name}{status}")
                log_message_util(self.app.root, self.log_text, "VERBOSE: Pivot table processed for non-reporters.", 'success')
            except Exception as e:
                log_message_util(self.app.root, self.log_text, f"VERBOSE: Could not process Pivot sheet. Non-reporter list will be empty. Error: {e}", 'error')
                self.non_reporters_data = {}


            sheet_title = str(pd.read_excel(xls, sheet_name='Summary Report', header=None, nrows=1).iloc[0,0])
            pp_match = re.search(r'PP(\d+)', sheet_title)
            if pp_match:
                self.current_pp.set(pp_match.group(1))
                log_message_util(self.app.root, self.log_text, f"Auto-detected Pay Period: {pp_match.group(1)}", 'success')

            for widget in self.office_list_frame.winfo_children():
                widget.destroy()
            self.office_vars = {}

            offices = self.dataframe['Office'].dropna().unique()
            for office_abbr in offices:
                full_name = self.app.office_name_map.get(office_abbr, "Unknown Office")
                display_text = f"{full_name} ({office_abbr})"
                var = tk.BooleanVar(value=True)
                cb = ttk.Checkbutton(self.office_list_frame, text=display_text, variable=var)
                cb.pack(anchor='w', padx=5, pady=2, fill='x')
                self.office_vars[office_abbr] = var

            self.generate_button.config(state='normal')
            log_message_util(self.app.root, self.log_text, f"Successfully loaded and cleaned {len(self.office_vars)} offices.", 'success')

        except Exception as e:
            log_message_util(self.app.root, self.log_text, f"Error loading file: {e}\n{traceback.format_exc()}", 'error')
            messagebox.showerror("File Load Error", str(e))

    def run_generation(self):
        if not self.current_pp.get().isdigit():
            messagebox.showerror("Input Error", "Please enter a valid number for the Pay Period.")
            return
        selected_offices = [office for office, var in self.office_vars.items() if var.get()]
        if not selected_offices:
            messagebox.showwarning("Selection Error", "Please select at least one office.")
            return

        self.generate_button.config(state='disabled')
        output_type = self.output_format.get()
        log_message_util(self.app.root, self.log_text, f"Generating {len(selected_offices)} emails for {output_type}...")

        thread = threading.Thread(target=self.generation_thread, args=(selected_offices, output_type))
        thread.start()

    def show_error_message(self, title, message):
        messagebox.showerror(title, message)

    def generation_thread(self, selected_offices, output_type):
        try:
            current_pp_num = int(self.current_pp.get())
            log_message_util(self.app.root, self.log_text, f"VERBOSE: Generation thread started for PP {current_pp_num}.")
            if output_type == "Word":
                doc = Document()
                style = doc.styles['Normal']
                font = style.font
                font.name = 'Aptos'
                font.size = Pt(11)

                for i, office in enumerate(selected_offices):
                    log_message_util(self.app.root, self.log_text, f"VERBOSE: Processing Word doc for office {i+1}/{len(selected_offices)}: {office}")
                    office_data = self.dataframe[self.dataframe['Office'] == office].iloc[0]
                    director_info = self.director_data.get(office, {})
                    non_reporters_list = self.non_reporters_data.get(office, [])
                    self.add_email_to_doc(doc, office_data, director_info, current_pp_num, non_reporters_list)

                manual_name = self.manual_filename.get().strip()
                if manual_name:
                    filename = manual_name if manual_name.endswith('.docx') else f"{manual_name}.docx"
                else:
                    timestamp = datetime.now()
                    filename = f"{timestamp.strftime('%Y.%m.%d')}_PP{current_pp_num} Emails to Office Directors_{timestamp.strftime('%H%M%S')}.docx"

                save_path = os.path.join(self.word_output_location.get(), filename)
                log_message_util(self.app.root, self.log_text, f"VERBOSE: Saving Word document to: {save_path}")
                doc.save(save_path)
                log_message_util(self.app.root, self.log_text, f"Word document saved to {os.path.basename(save_path)}", 'success')
                self.app.root.after(0, lambda: messagebox.showinfo("Success", f"File created:\n{os.path.basename(save_path)}\n\nSaved in folder:\n{os.path.dirname(save_path)}"))

            elif output_type == "Outlook":
                for i, office in enumerate(selected_offices):
                    log_message_util(self.app.root, self.log_text, f"VERBOSE: Processing Outlook email for office {i+1}/{len(selected_offices)}: {office}")
                    office_data = self.dataframe[self.dataframe['Office'] == office].iloc[0]
                    director_info = self.director_data.get(office, {})
                    non_reporters_list = self.non_reporters_data.get(office, [])
                    self.create_outlook_email(office_data, director_info, current_pp_num, non_reporters_list)
                self.app.root.after(0, lambda: messagebox.showinfo("Success", f"{len(selected_offices)} Outlook drafts have been created."))

        except Exception as e:
            error_message = f"An error occurred during generation: {e}\n\nFull Traceback:\n{traceback.format_exc()}"
            log_message_util(self.app.root, self.log_text, error_message, 'error')
            self.app.root.after(0, lambda err=error_message: self.show_error_message("Generation Error", err))
        finally:
            self.app.root.after(0, lambda: self.generate_button.config(state='normal'))

    def format_as_percent(self, value):
        if pd.isna(value):
            return ""
        try:
            if isinstance(value, str) and '%' in value:
                return value
            numeric_value = float(value)
            return f"{numeric_value:.2%}"
        except (ValueError, TypeError):
            return str(value)

    def get_next_pp_reminder(self, current_pp_num):
        if self.dates_df is None:
            return "As a reminder, the ITR reporting deadline is 11:59 pm on Monday following the end of each Pay Period."

        try:
            next_pp_num = current_pp_num + 1
            if current_pp_num == 25: next_pp_num = 1

            next_pp_data = self.dates_df[self.dates_df['Pay Period'] == next_pp_num].iloc[0]

            start_date_raw = next_pp_data['PP Start Date']
            end_date_raw = next_pp_data['PP End Date']

            start_date = pd.to_datetime(start_date_raw).strftime('%#m/%#d/%y')
            end_date = pd.to_datetime(end_date_raw).strftime('%#m/%#d/%y')

            deadline_text = str(next_pp_data['Reporting Deadline Text'])
            due_by_match = re.search(r'(due by .* on .*?, .* \d+)', deadline_text)
            due_by_text = due_by_match.group(1) if due_by_match else "due by 11:59 pm on Monday"

            return {
                "part1": "As a reminder, the ITR reporting deadline is ", "part1_bold": "11:59 pm on Monday",
                "part2": " following the end of each Pay Period. The next time this deadline occurs will be for ",
                "part2_bold": f"PP{next_pp_num} ({start_date}-{end_date})", "part3": ", with reports ",
                "part3_bold": f"{due_by_text}", "part4": "."
            }
        except Exception as e:
            log_message_util(self.app.root, self.log_text, f"VERBOSE: Error in get_next_pp_reminder: {e}", 'error')
            return "As a reminder, the ITR reporting deadline is 11:59 pm on Monday following the end of each Pay Period."

    def create_html_body(self, data, director_info, current_pp_num, non_reporters_list):
        """Builds the HTML content for the body of the Outlook email."""
        pay_period = str(current_pp_num)
        office_abbr = data['Office']
        director_name = director_info.get('Director Name', '<<Director_Name>>')
        office_final_rate = self.format_as_percent(data['Final Participation Rate'])
        office_initial_rate = self.format_as_percent(data['Initial Participation Rate'])

        non_reporters_section = ""
        if non_reporters_list:
            formatted_list_items = []
            for item in non_reporters_list:
                if " - " in item:
                    name, status = item.split(" - ", 1)
                    formatted_list_items.append(f"<li><b>{name}</b> - {status}</li>")
                else:
                    formatted_list_items.append(f"<li><b>{item}</b></li>")

            non_reporters_html = "".join(formatted_list_items)
            non_reporters_section = f'<b><u>Users who did not report or had proxy:</u></b><ul style="margin-top:0px;">{non_reporters_html}</ul>'

        reminder = self.get_next_pp_reminder(current_pp_num)
        if isinstance(reminder, dict):
            reminder_html = f"{reminder['part1']}<b>{reminder['part1_bold']}</b>{reminder['part2']}<b>{reminder['part2_bold']}</b>{reminder['part3']}<b>{reminder['part3_bold']}</b>{reminder['part4']}"
        else:
            reminder_html = reminder

        signature_html = """
        <p style="margin:0; font-family:Arial, sans-serif; font-size:11pt; color:#002060;">
            <b>Nathan A. Allen, CBER ITR Support Team</b>
        </p>
        <p style="margin:0; font-family:Arial, sans-serif; font-size:8.5pt; color:#595959;">
            <b>Insight Time Reporting (ITR) Support Team</b>
        </p>
        <p style="margin:0; font-family:Arial, sans-serif; font-size:8.5pt; color:#595959;">
            <b>Center for Biologics Evaluation and Research (CBER)</b>
        </p>
        """

        html = f"""<div style="font-family:Aptos, Calibri, sans-serif; font-size:11pt; color:black;"><p>Hello {director_name},<br><br>Last week, CBER completed time reporting in ITR Pay Period <b>{pay_period}</b>. Across CBER, <b>100.00%</b> of staff reported their full Tour of Duty (TOD), and <b>95.54%</b> reported partial hours.<br><br>In Pay Period <b>{pay_period}</b>, <b>{office_abbr}</b> had an unassisted (initial) percentage of <b>{office_initial_rate}</b> which is the percent of staff who entered their full Tour of Duty in ITR by the 11:59pm ET Monday deadline. <b>{office_abbr}</b>'s final participation rate is <b>{office_final_rate}</b>; this includes staff who reported part of their time, had their time proxied, or entered their hours after the deadline.<br><br>Details of <b>{office_abbr}</b>'s ITR reporting compared to the CBER-wide average are below.</p><table style="border-collapse:collapse; border:1px solid black; font-family:Aptos, Calibri, sans-serif; font-size:11pt;"><tr style="background-color:#1F497D; color:white; font-weight:bold;"><td style="border:1px solid black; padding:5px;">Office</td><td style="border:1px solid black; padding:5px;">Final Participation Rate</td><td style="border:1px solid black; padding:5px;">Initial Participation Rate</td></tr><tr><td style="border:1px solid black; padding:5px;"><b>{office_abbr}</b></td><td style="border:1px solid black; padding:5px;">{office_final_rate}</td><td style="border:1px solid black; padding:5px;">{office_initial_rate}</td></tr><tr><td style="border:1px solid black; padding:5px;"><b>Center</b></td><td style="border:1px solid black; padding:5px;">100.00%</td><td style="border:1px solid black; padding:5px;">95.54%</td></tr></table><p>{non_reporters_section}{reminder_html}<br><br>If you have any questions regarding the data you received, please reach out to the <a href="mailto:cber.itrhelpdesk@fda.hhs.gov">CBER ITR Helpdesk</a>, and the team will happily address them.</p>{signature_html}</div>"""
        return html

    def create_outlook_email(self, data, director_info, current_pp_num, non_reporters_list):
        """Creates and displays a new Outlook email draft."""
        outlook = win32.Dispatch('outlook.application')
        mail = outlook.CreateItem(0)
        office_abbr = data['Office']
        pay_period = str(current_pp_num)
        cc_emails = [director_info.get(f'CC {i}') for i in range(1, 12)]
        bcc_emails = [director_info.get(f'BCC {i}') for i in range(1, 3)]

        mail.To = director_info.get('Director Email', '')
        mail.CC = "; ".join(filter(pd.notna, [director_info.get('Deputy Email')] + cc_emails))
        mail.BCC = "; ".join(filter(pd.notna, bcc_emails))
        mail.Subject = f"{office_abbr} ITR Participation Report for FY25 PP{pay_period}"
        mail.HTMLBody = self.create_html_body(data, director_info, current_pp_num, non_reporters_list)
        mail.Display()

    def set_cell_background(self, cell, fill_color):
        """Helper function to set the background color of a table cell in a Word document."""
        shading_elm = OxmlElement('w:shd')
        shading_elm.set(qn('w:fill'), fill_color)
        cell._tc.get_or_add_tcPr().append(shading_elm)

    def add_email_to_doc(self, doc, data, director_info, current_pp_num, non_reporters_list):
        """Adds the content of a single email to the Word document."""
        office_abbr = data['Office']
        pay_period = str(current_pp_num)
        office_final_rate = self.format_as_percent(data['Final Participation Rate'])
        office_initial_rate = self.format_as_percent(data['Initial Participation Rate'])

        cc_emails = [director_info.get(f'CC {i}') for i in range(1, 12)]
        bcc_emails = [director_info.get(f'BCC {i}') for i in range(1, 3)]
        to_line = director_info.get('Director Email', '')
        cc_line = "; ".join(filter(pd.notna, [director_info.get('Deputy Email')] + cc_emails))
        bcc_line = "; ".join(filter(pd.notna, bcc_emails))

        # --- SPACING FIX: Set space_after to 0 for all paragraphs before the table ---
        p_to = doc.add_paragraph()
        p_to.paragraph_format.space_after = Pt(0)
        p_to.add_run("To: ").bold = True
        p_to.add_run(to_line)

        p_cc = doc.add_paragraph()
        p_cc.paragraph_format.space_after = Pt(0)
        p_cc.add_run("CC: ").bold = True
        p_cc.add_run(cc_line)

        p_bcc = doc.add_paragraph()
        p_bcc.paragraph_format.space_after = Pt(0)
        p_bcc.add_run("BCC: ").bold = True
        p_bcc.add_run(bcc_line)

        p_subj = doc.add_paragraph()
        p_subj.paragraph_format.space_after = Pt(0)
        p_subj.add_run("Subject: ").bold = True
        p_subj.add_run(f"{office_abbr} ITR Participation Report for FY25 PP{pay_period}")

        doc.add_paragraph("---").paragraph_format.space_after = Pt(0)

        p_hello = doc.add_paragraph(f"Hello {director_info.get('Director Name', 'Director')},")
        p_hello.paragraph_format.space_before = Pt(12)
        p_hello.paragraph_format.space_after = Pt(12)

        p1 = doc.add_paragraph("Last week, CBER completed time reporting in ITR Pay Period ")
        p1.paragraph_format.space_after = Pt(12)
        p1.add_run(f"{pay_period}").bold = True
        p1.add_run(". Across CBER, ")
        p1.add_run("100.00%").bold = True
        p1.add_run(" of staff reported their full Tour of Duty (TOD), and ")
        p1.add_run("95.54%").bold = True
        p1.add_run(" reported partial hours.")

        p2 = doc.add_paragraph("In Pay Period ")
        p2.paragraph_format.space_after = Pt(12)
        p2.add_run(f"{pay_period}").bold = True
        p2.add_run(", ")
        p2.add_run(f"{office_abbr}").bold = True
        p2.add_run(" had an unassisted (initial) percentage of ")
        p2.add_run(f"{office_initial_rate}").bold = True
        p2.add_run(" which is the percent of staff who entered their full Tour of Duty in ITR by the 11:59pm ET Monday deadline. ")
        p2.add_run(f"{office_abbr}").bold = True
        p2.add_run("'s final participation rate is ")
        p2.add_run(f"{office_final_rate}").bold = True
        p2.add_run("; this includes staff who reported part of their time, had their time proxied, or entered their hours after the deadline.")

        p3 = doc.add_paragraph("Details of ")
        p3.paragraph_format.space_after = Pt(12)
        p3.add_run(f"{office_abbr}").bold = True
        p3.add_run("'s ITR reporting compared to the CBER-wide average are below.")

        table = doc.add_table(rows=1, cols=3)
        table.style = 'Table Grid'
        table.autofit = False
        table.allow_autofit = False
        table.columns[0].width = Inches(1.0)
        table.columns[1].width = Inches(1.25)
        table.columns[2].width = Inches(1.25)
        hdr_cells = table.rows[0].cells
        hdr_cells[0].text = 'Office'
        hdr_cells[1].text = 'Final Participation Rate'
        hdr_cells[2].text = 'Initial Participation Rate'
        for cell in hdr_cells:
            cell.paragraphs[0].runs[0].font.bold = True
            cell.paragraphs[0].runs[0].font.color.rgb = RGBColor(0xFF, 0xFF, 0xFF)
            self.set_cell_background(cell, "1F497D")

        row_cells_1 = table.add_row().cells
        row_cells_1[0].add_paragraph().add_run(office_abbr).bold = True
        row_cells_1[1].text = office_final_rate
        row_cells_1[2].text = office_initial_rate

        row_cells_2 = table.add_row().cells
        row_cells_2[0].add_paragraph().add_run("Center").bold = True
        row_cells_2[1].text = "100.00%"
        row_cells_2[2].text = "95.54%"

        if non_reporters_list:
            p4 = doc.add_paragraph()
            p4.paragraph_format.space_before = Pt(12)
            run = p4.add_run("Users who did not report or had proxy:")
            run.bold = True
            run.underline = True
            for item in non_reporters_list:
                p_item = doc.add_paragraph(style='List Bullet')
                p_item.paragraph_format.left_indent = Inches(0.5)
                p_item.paragraph_format.first_line_indent = Inches(-0.25)
                if " - " in item:
                    name, status = item.split(" - ", 1)
                    p_item.add_run(name).bold = True
                    p_item.add_run(f" - {status}")
                else:
                    p_item.add_run(item).bold = True

        reminder = self.get_next_pp_reminder(current_pp_num)
        if isinstance(reminder, dict):
            p5 = doc.add_paragraph()
            p5.paragraph_format.space_before = Pt(12)
            p5.add_run(reminder['part1'])
            p5.add_run(reminder['part1_bold']).bold = True
            p5.add_run(reminder['part2'])
            p5.add_run(reminder['part2_bold']).bold = True
            p5.add_run(reminder['part3'])
            p5.add_run(reminder['part3_bold']).bold = True
            p5.add_run(reminder['part4'])
        else:
            p_remind = doc.add_paragraph(reminder)
            p_remind.paragraph_format.space_before = Pt(12)

        p_final = doc.add_paragraph("If you have any questions regarding the data you received, please reach out to the CBER ITR Helpdesk, and the team will happily address them.")
        p_final.paragraph_format.space_before = Pt(12)

        # Signature block for Word doc
        p_sig1 = doc.add_paragraph()
        p_sig1.paragraph_format.space_before = Pt(12)
        p_sig1.paragraph_format.space_after = Pt(0)
        run_sig1 = p_sig1.add_run('Nathan A. Allen, CBER ITR Support Team')
        run_sig1.font.name = 'Arial'
        run_sig1.bold = True
        run_sig1.font.size = Pt(11)
        run_sig1.font.color.rgb = RGBColor(0x00, 0x20, 0x60)

        p_sig2 = doc.add_paragraph()
        p_sig2.paragraph_format.space_before = Pt(0)
        p_sig2.paragraph_format.space_after = Pt(0)
        run_sig2 = p_sig2.add_run('Insight Time Reporting (ITR) Support Team')
        run_sig2.font.name = 'Arial'
        run_sig2.bold = True
        run_sig2.font.size = Pt(8.5)
        run_sig2.font.color.rgb = RGBColor(0x59, 0x59, 0x59)

        p_sig3 = doc.add_paragraph()
        p_sig3.paragraph_format.space_before = Pt(0)
        p_sig3.paragraph_format.space_after = Pt(0)
        run_sig3 = p_sig3.add_run('Center for Biologics Evaluation and Research (CBER)')
        run_sig3.font.name = 'Arial'
        run_sig3.bold = True
        run_sig3.font.size = Pt(8.5)
        run_sig3.font.color.rgb = RGBColor(0x59, 0x59, 0x59)

        doc.add_page_break()

#==========================================================================
# MAIN APPLICATION CLASS
#==========================================================================
class MasterWorkflowApp:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("Master Workflow Tool")
        self.root.geometry("1100x850")

        self.style = ttk.Style()
        self.style.theme_use('clam')

        self.BG_COLOR = '#FFFFFF'
        self.FG_COLOR = '#212121'
        self.WIDGET_BG = '#F5F5F5'
        self.BORDER_COLOR = '#E0E0E0'
        self.ACCENT_COLOR_GREEN = '#81C784'
        self.ACCENT_COLOR_BLUE = '#64B5F6'
        self.ACCENT_COLOR_PURPLE = '#9575CD'
        self.NEUTRAL_BUTTON_BG = '#EEEEEE'
        self.NEUTRAL_BUTTON_ACTIVE = '#E0E0E0'

        self.root.configure(bg=self.BG_COLOR)

        self.style.configure('.', background=self.BG_COLOR, foreground=self.FG_COLOR, font=('Helvetica', 11))
        self.style.configure('TFrame', background=self.BG_COLOR)
        self.style.configure('TLabel', background=self.BG_COLOR, foreground=self.FG_COLOR)
        self.style.configure('Info.TLabel', foreground='#616161', font=('Helvetica', 9))
        self.style.configure('Bold.TLabel', font=('Helvetica', 11, 'bold'))
        self.style.configure('Header.TLabel', font=('Helvetica', 18, 'bold'))

        self.style.configure('MutedGreen.TButton', background=self.ACCENT_COLOR_GREEN, foreground='black', font=('Helvetica', 12, 'bold'), borderwidth=0)
        self.style.map('MutedGreen.TButton', background=[('active', '#66BB6A'), ('disabled', '#E0E0E0')])
        self.style.configure('MutedBlue.TButton', background=self.ACCENT_COLOR_BLUE, foreground='black', font=('Helvetica', 12, 'bold'), borderwidth=0)
        self.style.map('MutedBlue.TButton', background=[('active', '#42A5F5'), ('disabled', '#E0E0E0')])
        self.style.configure('MutedPurple.TButton', background=self.ACCENT_COLOR_PURPLE, foreground='white', font=('Helvetica', 12, 'bold'), borderwidth=0)
        self.style.map('MutedPurple.TButton', background=[('active', '#7E57C2'), ('disabled', '#E0E0E0')])
        self.style.configure('Neutral.TButton', background=self.NEUTRAL_BUTTON_BG, foreground='black', font=('Helvetica', 10), borderwidth=1, relief='solid', bordercolor=self.BORDER_COLOR)
        self.style.map('Neutral.TButton', background=[('active', self.NEUTRAL_BUTTON_ACTIVE), ('disabled', '#F5F5F5')])

        self.style.configure('TCombobox', fieldbackground=self.WIDGET_BG, background=self.WIDGET_BG, foreground=self.FG_COLOR, arrowcolor=self.FG_COLOR, bordercolor=self.BORDER_COLOR, lightcolor=self.WIDGET_BG, darkcolor=self.WIDGET_BG)
        self.style.configure('TEntry', fieldbackground=self.WIDGET_BG, foreground=self.FG_COLOR, bordercolor=self.BORDER_COLOR, lightcolor=self.WIDGET_BG, darkcolor=self.WIDGET_BG)
        self.style.map('TEntry', fieldbackground=[('readonly', self.WIDGET_BG)])

        self.style.configure('MutedGreen.Horizontal.TProgressbar', troughcolor=self.WIDGET_BG, background=self.ACCENT_COLOR_GREEN, thickness=15, borderwidth=0)
        self.style.configure('MutedBlue.Horizontal.TProgressbar', troughcolor=self.WIDGET_BG, background=self.ACCENT_COLOR_BLUE, thickness=15, borderwidth=0)

        self.style.configure('TLabelframe', background=self.BG_COLOR, bordercolor=self.BORDER_COLOR)
        self.style.configure('TLabelframe.Label', background=self.BG_COLOR, foreground=self.FG_COLOR, font=('Helvetica', 12, 'bold'))

        self.style.configure('TNotebook', background=self.BG_COLOR, borderwidth=0)
        self.style.configure('TNotebook.Tab', background='#FAFAFA', foreground='#616161', padding=[15, 8], font=('Helvetica', 11, 'bold'), borderwidth=0)
        self.style.map('TNotebook.Tab', background=[('selected', self.BG_COLOR)], foreground=[('selected', self.ACCENT_COLOR_BLUE)])

        self.style.configure('TRadiobutton', background=self.BG_COLOR, foreground=self.FG_COLOR)
        self.style.map('TRadiobutton', indicatorcolor=[('selected', self.ACCENT_COLOR_BLUE)], background=[('active', self.BG_COLOR)])
        self.style.configure('TCheckbutton', background=self.BG_COLOR, foreground=self.FG_COLOR)
        self.style.map('TCheckbutton', indicatorcolor=[('selected', self.ACCENT_COLOR_BLUE)], background=[('active', self.BG_COLOR)])

        self.default_output_path = get_default_output_path()
        self.office_name_map = {
            'OBPV': 'OFFICE OF BIOSTATISTICS & PHARMACOVIGILANCE', 'OBRR': 'OFFICE OF BLOOD RESEARCH AND REVIEW',
            'OCBQ': 'OFFICE OF COMPLIANCE AND BIOLOGICS QUALITY', 'OCOD': 'OFFICE OF COMMUNICATION, OUTREACH AND DEVELOPMENT',
            'OD': 'OFFICE OF THE CENTER DIRECTOR', 'OM': 'OFFICE OF MANAGEMENT',
            'ORO': 'OFFICE OF REGULATORY OPERATIONS', 'OTP': 'OFFICE OF THERAPEUTIC PRODUCTS',
            'OVRR': 'OFFICE OF VACCINES RESEARCH AND REVIEW'
        }

        main_frame = ttk.Frame(self.root, padding="20")
        main_frame.pack(expand=True, fill='both')

        notebook = ttk.Notebook(main_frame, style='TNotebook')
        notebook.pack(expand=True, fill='both')

        reporter_tab = ReporterFrame(notebook, self, padding="20")
        formatter_tab = FormatterFrame(notebook, self, padding="20")
        emailer_tab = EmailerFrame(notebook, self, padding="20")

        notebook.add(reporter_tab, text='Pay Period Reporter')
        notebook.add(formatter_tab, text='Helper Sheet Formatter')
        notebook.add(emailer_tab, text='Office Emailer')

    def run(self):
        self.root.mainloop()

if __name__ == "__main__":
    app = MasterWorkflowApp()
    app.run()